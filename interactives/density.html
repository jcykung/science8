<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Density Interactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Prevents pull-to-refresh on mobile */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none; /* Safari */
            user-select: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        /* Hide Scrollbar for cleaner UI */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px; /* Larger touch target for mobile */
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }

        /* Specific slider styles for lake temp to distinguish it */
        #lakeTempSlider::-webkit-slider-thumb {
            background: #10b981; /* Emerald-500 */
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 100px;
            flex: 1;
        }

        .formula-container {
            display: flex;
            align-items: center;
            background: #f8fafc;
            border: 1px solid #cbd5e1;
            padding: 6px 10px;
            border-radius: 12px;
            gap: 6px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            flex-wrap: wrap;
            justify-content: center;
        }

        .variable-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .fraction {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .numerator {
            border-bottom: 2px solid #94a3b8;
            padding-bottom: 2px;
            margin-bottom: 2px;
            text-align: center;
            width: 100%;
        }

        .var-label {
            font-size: 0.65rem;
            letter-spacing: 0.02em;
            color: #64748b;
            font-weight: 600;
            white-space: nowrap;
        }

        .var-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #0f172a;
            font-size: 1rem;
        }

        .equals {
            font-size: 1rem;
            color: #94a3b8;
            font-weight: 300;
        }

        .tab-btn {
            padding: 12px 16px; /* Larger tap area */
            font-size: 0.85rem;
            font-weight: 600;
            color: #64748b;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab-btn.active {
            color: #2563eb;
            border-bottom-color: #2563eb;
        }

        .tab-content {
            display: none;
            width: 100%;
            height: 100%;
            flex: 1;
            position: relative;
        }

        .tab-content.active {
            display: block;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #475569;
            cursor: pointer;
            padding: 4px 0;
        }

        .radio-label input {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            accent-color: #2563eb;
        }
        
        .tower-btn {
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            font-weight: 600;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .tower-btn:hover:not(:disabled) { background: #f1f5f9; border-color: #94a3b8; }
        .tower-btn:active:not(:disabled) { transform: scale(0.98); }
        .tower-btn:disabled { opacity: 0.5; cursor: not-allowed; border-style: dashed; }
        
        .dot-indicator { width: 8px; height: 8px; border-radius: 50%; }

        /* Mobile Optimizations */
        @media (max-width: 640px) {
            .glass-panel h1 { font-size: 1.1rem; }
            .control-group label { font-size: 0.7rem; }
            .control-group span { font-size: 0.7rem; }
            .formula-container { transform: scale(0.9); transform-origin: left center; }
        }
    </style>
</head>

<body class="bg-slate-100 h-screen flex flex-col relative overflow-hidden">

    <!-- Header Section -->
    <div class="glass-panel w-full z-20 flex flex-col shrink-0">
        <div class="bg-slate-50 border-b border-slate-200 px-3 py-2 md:px-6 md:py-3">
            <h1 class="text-lg md:text-xl font-bold text-slate-800">Density Interactive</h1>
            <p class="text-xs md:text-sm text-slate-600 mt-1 max-w-3xl leading-relaxed hidden sm:block">
                <strong>Density (D)</strong> is a measure of how much matter (m) is packed into a specific space (V).
                High density means particles are packed tightly together.
            </p>
        </div>

        <div class="flex px-0 md:px-6 border-b border-slate-200 bg-white overflow-x-auto no-scrollbar">
            <button class="tab-btn active" onclick="switchTab('macro')">1. What is density?</button>
            <button class="tab-btn" onclick="switchTab('tower')">2. Density Tower</button>
            <button class="tab-btn" onclick="switchTab('micro')">3. Why is ice less dense?</button>
            <button class="tab-btn" onclick="switchTab('lake')">4. Why is density important?</button>
        </div>

        <!-- 1. Macro Controls -->
        <div id="macroControls" class="p-2 md:p-4 flex flex-col md:flex-row flex-wrap items-center justify-between gap-3 md:gap-4 max-h-[35vh] overflow-y-auto overscroll-contain">
            <div class="formula-container w-full md:w-auto justify-between md:justify-center bg-blue-50/50 md:bg-slate-50">
                <div class="variable-group">
                    <span class="var-label text-blue-600">Density</span>
                    <span id="formulaD" class="var-value text-blue-600">0.80</span>
                    <span class="text-[9px] text-slate-400">g/cm³</span>
                </div>
                <div class="equals">=</div>
                <div class="fraction">
                    <div class="numerator">
                        <div class="variable-group">
                            <span class="var-value" id="formulaM">800</span>
                            <span class="var-label">mass (g)</span>
                        </div>
                    </div>
                    <div class="variable-group">
                        <span class="var-value" id="formulaV">1000</span>
                        <span class="var-label">Volume (cm³)</span>
                    </div>
                </div>
                
                <div class="flex md:hidden items-center gap-2 ml-2 border-l pl-2 border-slate-300">
                    <label class="text-[10px] font-semibold text-slate-600">Gravity</label>
                    <input type="checkbox" id="forceToggleMobile" class="accent-blue-600 w-5 h-5" checked onchange="syncGravity(this.checked)">
                </div>
            </div>

            <div class="grid grid-cols-2 md:flex md:flex-1 w-full gap-3 md:gap-6 items-end justify-end">
                <div class="control-group">
                    <div class="flex justify-between text-xs mb-1">
                        <label class="font-bold text-slate-700">Mass</label>
                        <span id="massVal" class="font-mono text-slate-600 bg-slate-100 px-1 rounded text-[10px]">800 g</span>
                    </div>
                    <input type="range" id="massSlider" min="100" max="3000" step="50" value="800" class="w-full">
                </div>
                <div class="control-group">
                    <div class="flex justify-between text-xs mb-1">
                        <label class="font-bold text-slate-700">Volume</label>
                        <span id="volVal" class="font-mono text-slate-600 bg-slate-100 px-1 rounded text-[10px]">1000 cm³</span>
                    </div>
                    <input type="range" id="volSlider" min="200" max="5000" step="50" value="1000" class="w-full">
                </div>
                <div class="control-group col-span-2 md:col-span-1 md:border-l md:pl-6 border-slate-200">
                    <div class="flex justify-between text-xs mb-1">
                        <label class="font-bold text-slate-700">Density</label>
                        <span id="densityVal" class="font-bold text-blue-600 bg-blue-50 px-2 rounded text-[10px]">0.80 g/cm³</span>
                    </div>
                    <input type="range" id="densitySlider" min="0.1" max="3.0" step="0.1" value="0.8" class="w-full">
                </div>
            </div>

            <div class="hidden md:flex items-center gap-2 border-l pl-4 w-auto justify-end">
                <label class="text-xs font-semibold text-slate-600">Gravity</label>
                <input type="checkbox" id="forceToggle" class="accent-blue-600 w-5 h-5" checked onchange="syncGravity(this.checked)">
            </div>
        </div>

        <!-- 2. Tower Controls - Redesigned Horizontal Layout -->
        <div id="towerControls" class="p-3 md:p-4 hidden flex-row flex-wrap items-start gap-6 bg-slate-50 overflow-y-auto max-h-[35vh]">
            
            <div class="flex flex-col gap-2 shrink-0">
                <span class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">1. Add Liquids First</span>
                <div class="flex flex-wrap gap-2">
                    <button class="tower-btn" onclick="addTowerLiquid('oil')"><div class="dot-indicator bg-yellow-400"></div>Oil (0.9)</button>
                    <button class="tower-btn" onclick="addTowerLiquid('water')"><div class="dot-indicator bg-blue-500"></div>Water (1.0)</button>
                    <button class="tower-btn" onclick="addTowerLiquid('honey')"><div class="dot-indicator bg-amber-700"></div>Honey (1.4)</button>
                </div>
            </div>

            <div class="flex flex-col gap-2 shrink-0">
                <span class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">2. Add Solids</span>
                <div class="flex flex-wrap gap-2" id="solidButtonsContainer">
                    <button class="tower-btn solid-btn" disabled onclick="addTowerSolid('sponge')"><div class="dot-indicator bg-pink-300"></div>Sponge (0.1)</button>
                    <button class="tower-btn solid-btn" disabled onclick="addTowerSolid('wax')"><div class="dot-indicator bg-yellow-100 border border-slate-300"></div>Beeswax (0.95)</button>
                    <button class="tower-btn solid-btn" disabled onclick="addTowerSolid('plastic')"><div class="dot-indicator bg-sky-300"></div>Plastic (1.0)</button>
                    <button class="tower-btn solid-btn" disabled onclick="addTowerSolid('rubber')"><div class="dot-indicator bg-slate-400"></div>Rubber (1.2)</button>
                    <button class="tower-btn solid-btn" disabled onclick="addTowerSolid('brick')"><div class="dot-indicator bg-[#800000]"></div>Brick (1.9)</button>
                </div>
            </div>

            <div class="flex items-end flex-1 justify-end h-full">
                 <button class="px-4 py-2 bg-white hover:bg-red-50 text-red-500 font-bold border border-red-200 rounded-lg transition-colors text-sm" onclick="resetTower()">
                    Reset Tower
                 </button>
            </div>
        </div>

        <!-- 3. Micro Controls -->
        <div id="microControls" class="p-3 md:p-4 hidden flex-col md:flex-row items-center justify-center gap-4 md:gap-8 bg-blue-50/50 max-h-[35vh] overflow-y-auto">
            <div class="flex flex-col items-center w-full md:w-64">
                <label class="text-xs md:text-sm font-bold text-slate-700 mb-1">Temperature</label>
                <input type="range" id="tempSlider" min="-20" max="20" step="1" value="20" class="w-full">
                <div class="flex justify-between w-full text-xs text-slate-500 mt-1 font-mono">
                    <span>Ice</span>
                    <span id="tempVal" class="font-bold text-blue-600 text-sm">20°C</span>
                    <span>Water</span>
                </div>
            </div>
            <div class="text-xs md:text-sm text-slate-600 w-full md:max-w-md bg-white p-3 rounded-lg border border-blue-100 shadow-sm">
                <strong id="phaseTitle" class="text-blue-700 block mb-1">Liquid Water:</strong>
                <span id="phaseDesc">Heat energy breaks bonds. Molecules slide closer together into a tighter volume.</span>
            </div>
        </div>

        <!-- 4. Lake Controls -->
        <div id="lakeControls" class="p-3 md:p-4 hidden flex-col md:flex-row items-center justify-between gap-4 bg-emerald-50/50 w-full h-auto">
            
            <!-- Controls Container (Left) -->
            <div class="flex flex-col md:flex-row gap-4 items-center flex-1 w-full">
                
                <!-- Mode Toggle -->
                <div class="bg-white p-2 rounded-xl border border-emerald-100 shadow-sm shrink-0 flex items-center justify-center md:justify-start gap-4 px-4 w-full md:w-auto">
                     <span class="text-xs font-bold text-slate-500 uppercase self-center hidden md:block">Mode:</span>
                     <div class="radio-group flex flex-row gap-4">
                        <label class="radio-label p-0">
                            <input type="radio" name="lakeScenario" value="real" checked onchange="updateLakeScenario(this.value)">
                            <span class="font-bold text-slate-700 text-xs md:text-sm">Real World</span>
                        </label>
                        <label class="radio-label p-0">
                            <input type="radio" name="lakeScenario" value="hypothetical" onchange="updateLakeScenario(this.value)">
                            <span class="font-bold text-slate-700 text-xs md:text-sm">Hypothetical</span>
                        </label>
                     </div>
                </div>

                <!-- Long Slider -->
                <div class="flex flex-col w-full md:max-w-2xl bg-white/60 p-3 rounded-xl border border-emerald-100/50">
                    <div class="flex justify-between items-end mb-2">
                        <label class="text-xs font-bold text-slate-700">Water Temperature</label>
                        <span id="lakeTempVal" class="font-mono font-bold text-emerald-600 text-sm">20°C</span>
                    </div>
                    <input type="range" id="lakeTempSlider" min="-20" max="20" step="1" value="20" class="w-full accent-emerald-500 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between w-full text-[10px] text-slate-400 mt-1 font-mono">
                        <span>-20°C</span>
                        <span>0°C</span>
                        <span>20°C</span>
                    </div>
                </div>

            </div>

            <!-- Explanation Box (Right, Max 1/3) -->
            <div class="bg-white p-3 rounded-xl border border-emerald-200 shadow-sm w-full md:w-1/3 md:max-w-sm shrink-0 text-left self-stretch flex flex-col justify-center">
                <h3 id="lakeTitle" class="font-bold text-emerald-800 text-xs mb-1">Winter in the Lake</h3>
                <p id="lakeDesc" class="text-xs text-slate-600 leading-snug">
                    Ice floats on top because it is less dense than liquid water. This layer insulates the lake, allowing aquatic life to survive the winter.
                </p>
            </div>

        </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="relative flex-1 w-full bg-slate-200 overflow-hidden touch-none">
        <div id="tab-macro" class="tab-content active"><canvas id="simCanvas" class="w-full h-full"></canvas>
            <div class="absolute bottom-4 left-4 md:bottom-6 md:left-6 pointer-events-none">
                <div class="bg-white/80 backdrop-blur px-3 py-1.5 md:px-4 md:py-2 rounded-lg shadow-lg border border-white/50">
                    <span class="text-[10px] md:text-xs text-slate-500 uppercase tracking-wide">Status</span>
                    <div id="statusVal" class="text-base md:text-lg font-bold text-green-600">Floating</div>
                </div>
            </div>
        </div>
        
        <div id="tab-tower" class="tab-content bg-slate-100">
            <canvas id="towerCanvas" class="w-full h-full"></canvas>
             <div class="absolute bottom-4 right-4 pointer-events-none text-right">
                <div class="bg-white/90 backdrop-blur px-3 py-2 rounded-lg shadow-sm border border-slate-200 inline-block text-xs text-slate-500">
                   <p>Particles show density.</p>
                   <p>Closer = Denser</p>
                </div>
            </div>
        </div>

        <div id="tab-micro" class="tab-content bg-slate-800"><canvas id="microCanvas" class="w-full h-full"></canvas>
            <div class="absolute bottom-4 right-4 md:bottom-6 md:right-6 pointer-events-none">
                <div class="bg-slate-900/80 text-white backdrop-blur px-3 py-2 md:px-4 md:py-3 rounded-lg shadow-lg border border-slate-700 max-w-[150px] md:max-w-none">
                    <div class="flex items-center gap-2 mb-2">
                        <div class="w-3 h-3 rounded-full bg-red-500 shrink-0"></div> <span class="text-xs">Oxygen</span>
                    </div>
                    <div class="flex items-center gap-2 mb-2">
                        <div class="w-2 h-2 rounded-full bg-slate-300 shrink-0"></div> <span class="text-xs">Hydrogen</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-0 border-t-2 border-dashed border-yellow-400/50 shrink-0"></div> <span class="text-xs">H-Bond</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="tab-lake" class="tab-content"><canvas id="lakeCanvas" class="w-full h-full"></canvas></div>
    </div>

    <script>
        let currentTab = 'macro';

        // --- Globals ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const towerCanvas = document.getElementById('towerCanvas');
        const tCtx = towerCanvas.getContext('2d');
        const microCanvas = document.getElementById('microCanvas');
        const mCtx = microCanvas.getContext('2d');
        const lakeCanvas = document.getElementById('lakeCanvas');
        const lCtx = lakeCanvas.getContext('2d');

        // Macro UI
        const massSlider = document.getElementById('massSlider');
        const volSlider = document.getElementById('volSlider');
        const densitySlider = document.getElementById('densitySlider');
        const forceToggle = document.getElementById('forceToggle');
        const forceToggleMobile = document.getElementById('forceToggleMobile');
        
        const displays = {
            m: document.getElementById('massVal'), v: document.getElementById('volVal'), d: document.getElementById('densityVal'),
            status: document.getElementById('statusVal'), fM: document.getElementById('formulaM'), fV: document.getElementById('formulaV'), fD: document.getElementById('formulaD')
        };
        const MACRO_CONFIG = { WATER_LEVEL_RATIO: 0.55, GRAVITY: 0.5, WATER_DENSITY: 1.0, DAMPING: 0.96 };
        let width, height, waterLevel;
        const block = { x: 0, y: 0, size: 150, vx: 0, vy: 0, density: 0.8, mass: 800, volume: 1000, isDragging: false, submergedRatio: 0 };
        const mouse = { x: 0, y: 0, px: 0, py: 0, down: false };

        // Tower UI Globals
        let tWidth, tHeight;
        let towerLiquids = [];
        let towerSolids = [];
        let liquidsAdded = false;
        const TOWER_GRAVITY = 0.5;

        // Micro UI
        const tempSlider = document.getElementById('tempSlider');
        const tempDisplay = document.getElementById('tempVal');
        const phaseTitle = document.getElementById('phaseTitle');
        const phaseDesc = document.getElementById('phaseDesc');
        let mWidth, mHeight, molecules = [], temperature = 20, latticeBox = { x: 0, y: 0, w: 0, h: 0 };
        const BOND_DIST = 14;
        let currentBondAngle = 105 * (Math.PI / 180);

        // Lake UI
        const lakeTempSlider = document.getElementById('lakeTempSlider');
        const lakeTempDisplay = document.getElementById('lakeTempVal');
        const lakeTitle = document.getElementById('lakeTitle');
        const lakeDesc = document.getElementById('lakeDesc');
        let lWidth, lHeight, lakeTemp = 20, isRealWorld = true;
        let fishArray = [], plantArray = [], iceParticles = [], accumulatedBottomIce = 0;

        // --- Class Definitions ---
        class Molecule {
            constructor(id) {
                this.id = id; this.x = 0; this.y = 0; this.vx = 0; this.vy = 0; this.angle = 0;
                this.vAngle = (Math.random() - 0.5) * 0.1; this.targetX = 0; this.targetY = 0; this.targetAngle = 0;
            }
            getAtoms() {
                const a1 = this.angle - currentBondAngle / 2;
                const a2 = this.angle + currentBondAngle / 2;
                return {
                    o: { x: this.x, y: this.y },
                    h1: { x: this.x + Math.cos(a1) * BOND_DIST, y: this.y + Math.sin(a1) * BOND_DIST },
                    h2: { x: this.x + Math.cos(a2) * BOND_DIST, y: this.y + Math.sin(a2) * BOND_DIST }
                };
            }
            update(w, h, temp) {
                if (temp <= 0) {
                    const k = 0.08, kRot = 0.15;
                    this.vx = (this.targetX - this.x) * k; this.vy = (this.targetY - this.y) * k;
                    let diff = this.targetAngle - this.angle;
                    while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2;
                    this.angle += diff * kRot;
                    this.x += this.vx + (Math.random() - 0.5) * 0.3; this.y += this.vy + (Math.random() - 0.5) * 0.3;
                    currentBondAngle = 120 * (Math.PI / 180);
                } else {
                    const noise = 0.8 + (temp * 0.05);
                    this.vx += (Math.random() - 0.5) * noise; this.vy += (Math.random() - 0.5) * noise;
                    this.vx *= 0.95; this.vy *= 0.95;
                    const maxSpeed = 4.0, curSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (curSpeed > maxSpeed) { this.vx = (this.vx / curSpeed) * maxSpeed; this.vy = (this.vy / curSpeed) * maxSpeed; }
                    this.angle += this.vAngle * (1 + temp * 0.05);
                    this.x += this.vx; this.y += this.vy;
                    currentBondAngle = 105 * (Math.PI / 180);
                    const boxW = w * 0.35, boxH = h * 0.35, startX = (w - boxW) / 2, startY = (h - boxH) / 2, radius = 15;
                    molecules.forEach(other => {
                        if (other === this) return;
                        const dx = other.x - this.x, dy = other.y - this.y, dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 32 && dist > 0) {
                            const push = (32 - dist) * 0.08;
                            this.vx -= (dx / dist) * push; this.vy -= (dy / dist) * push;
                        }
                    });
                    if (this.x < startX + radius) { this.x = startX + radius; this.vx = Math.abs(this.vx); }
                    if (this.x > startX + boxW - radius) { this.x = startX + boxW - radius; this.vx = -Math.abs(this.vx); }
                    if (this.y < startY + radius) { this.y = startY + radius; this.vy = Math.abs(this.vy); }
                    if (this.y > startY + boxH - radius) { this.y = startY + boxH - radius; this.vy = -Math.abs(this.vy); }
                }
            }
            draw() {
                const atoms = this.getAtoms();
                mCtx.beginPath(); mCtx.moveTo(atoms.o.x, atoms.o.y); mCtx.lineTo(atoms.h1.x, atoms.h1.y);
                mCtx.moveTo(atoms.o.x, atoms.o.y); mCtx.lineTo(atoms.h2.x, atoms.h2.y);
                mCtx.strokeStyle = '#94a3b8'; mCtx.lineWidth = 3; mCtx.stroke();
                mCtx.fillStyle = '#cbd5e1'; mCtx.beginPath(); mCtx.arc(atoms.h1.x, atoms.h1.y, 6, 0, Math.PI * 2); mCtx.fill();
                mCtx.beginPath(); mCtx.arc(atoms.h2.x, atoms.h2.y, 6, 0, Math.PI * 2); mCtx.fill();
                mCtx.fillStyle = '#ef4444'; mCtx.beginPath(); mCtx.arc(atoms.o.x, atoms.o.y, 10, 0, Math.PI * 2); mCtx.fill();
            }
        }

        // --- Tower Classes ---
        class TowerLiquid {
            constructor(id, name, density, color) {
                this.id = id; this.name = name; this.density = density; this.color = color;
                this.height = 0; this.targetY = 0; this.currentY = 0; 
                this.currentH = 0; // Animate height
                // Particles
                this.particles = [];
                // Density determines particle count. More dense = More particles
                const count = Math.floor(density * 80);
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x: Math.random(), 
                        y: Math.random(), 
                        vx: (Math.random()-0.5)*0.002, 
                        vy: (Math.random()-0.5)*0.002
                    });
                }
            }
            update(y, h, width) {
                this.targetY = y;
                // Smoothly animate height and Y position
                this.currentH += (h - this.currentH) * 0.1;
                this.currentY += (this.targetY - this.currentY) * 0.1;
                
                // Update particles
                this.particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if(p.x < 0) p.x+=1; if(p.x>1) p.x-=1;
                    if(p.y < 0) p.y+=1; if(p.y>1) p.y-=1;
                });
            }
            draw(ctx, width) {
                ctx.fillStyle = this.color;
                ctx.fillRect(0, this.currentY, width, this.currentH);
                // Draw name - Increased padding to 60 to prevent cutoff
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText(`${this.name} (${this.density})`, 60, this.currentY + 20);
                // Draw particles
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                this.particles.forEach(p => {
                    const px = p.x * width;
                    const py = this.currentY + (p.y * this.currentH);
                    ctx.beginPath(); ctx.arc(px, py, 2, 0, Math.PI*2); ctx.fill();
                });
            }
        }

        class TowerSolid {
            constructor(name, density, color) {
                this.name = name; this.density = density; this.color = color;
                this.size = 60;
                this.x = tWidth/2 - this.size/2;
                this.y = 20; // Spawn at top
                this.vx = 0; this.vy = 0;
                this.isDragging = false;
                // Grid particles
                this.particles = [];
                const densityFactor = Math.sqrt(density); 
                const rows = Math.min(10, Math.max(2, Math.floor(densityFactor * 4)));
                const step = this.size / rows;
                const offset = step/2;
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<rows; c++) {
                        this.particles.push({x: c*step + offset, y: r*step + offset});
                    }
                }
            }
            update(liquids, width, height) {
                if(this.isDragging) return;

                // Find current medium density
                let fluidDensity = 0; // Air
                let inFluid = false;
                
                // ROBUST COLLISION: Use grid logic instead of hitbox logic
                // This prevents solids from falling through if liquids haven't animated yet
                if (liquids.length > 0) {
                    const cy = this.y + this.size/2;
                    const layerHeight = height / liquids.length;
                    
                    // Liquids are sorted by density (descending), so bottom is 0 in sorted array?
                    // No, updateTowerLogic loops: index 0 (Highest Density) -> targetY = Bottom
                    // So Index 0 is at bottom (high Y). Index Last is at top (low Y).
                    
                    // Map Y to stack index. 
                    // Y=0 -> Index Last (Oil)
                    // Y=Height -> Index 0 (Honey)
                    
                    // Flip Y to measure from bottom
                    const yFromBottom = height - cy;
                    // Prevent negative or out of bounds
                    if (yFromBottom > 0) {
                        const stackIndex = Math.floor(yFromBottom / layerHeight);
                        if (stackIndex >= 0 && stackIndex < liquids.length) {
                            fluidDensity = liquids[stackIndex].density;
                            inFluid = true;
                        }
                    }
                }

                // Physics
                const forceG = this.density * TOWER_GRAVITY;
                let forceB = 0;
                
                // Simplified Buoyancy
                const drag = inFluid ? 0.85 : 0.98; // Faster movement
                
                // Determine direction
                // Accel factor - Increased for snappy response
                const accel = (this.density - fluidDensity) * 0.3; 
                
                this.vy += accel;
                this.vy *= drag;
                this.y += this.vy;
                this.x += this.vx; this.vx *= drag;

                // Bounds
                if(this.y > height - this.size) {
                     this.y = height - this.size; 
                     this.vy = 0;
                }
                if(this.y < 0) { this.y = 0; this.vy = 0; } // Ceiling
                if(this.x < 0) { this.x = 0; this.vx *= -0.5; }
                if(this.x > width - this.size) { this.x = width - this.size; this.vx *= -0.5; }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.fillRect(0,0,this.size, this.size);
                ctx.strokeRect(0,0,this.size, this.size);
                
                // Label
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.size/2, -5);
                ctx.fillText(this.density, this.size/2, this.size + 12);

                // Particles
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.particles.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2); ctx.fill();
                });

                ctx.restore();
            }
        }

        class Fish {
            constructor() {
                const w = (typeof lWidth !== 'undefined' && lWidth > 0) ? lWidth : 800;
                this.x = Math.random() * w;
                this.y = 300 + Math.random() * 200;
                this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 0.5;
                this.size = 20 + Math.random() * 10; this.alive = true;
                this.color = `hsl(${Math.random() * 40 + 10}, 80%, 50%)`;
            }
            update(topBound, bottomBound) {
                if (topBound >= bottomBound - 15) this.alive = false;
                if (!this.alive) { if (this.y > topBound + 10) this.y -= 0.5; return; }
                this.x += this.vx; this.y += this.vy;
                if (this.x < 20 || this.x > lWidth - 20) this.vx *= -1;
                if (this.y < topBound + 15) { this.y = topBound + 15; this.vy = Math.abs(this.vy); }
                if (this.y > bottomBound - 15) { this.y = bottomBound - 15; this.vy = -Math.abs(this.vy); }
            }
            draw() {
                lCtx.save(); lCtx.translate(this.x, this.y); if (this.vx < 0) lCtx.scale(-1, 1);
                if (!this.alive) { lCtx.rotate(Math.PI); lCtx.filter = 'grayscale(100%)'; }
                lCtx.fillStyle = this.color; lCtx.beginPath(); lCtx.ellipse(0, 0, this.size, this.size / 2, 0, 0, Math.PI * 2); lCtx.fill();
                lCtx.beginPath(); lCtx.moveTo(-this.size, 0); lCtx.lineTo(-this.size - 10, -8); lCtx.lineTo(-this.size - 10, 8); lCtx.fill();
                lCtx.fillStyle = 'white'; lCtx.beginPath(); lCtx.arc(this.size / 2, -2, 4, 0, Math.PI * 2); lCtx.fill();
                lCtx.fillStyle = 'black'; lCtx.beginPath(); lCtx.arc(this.size / 2 + 2, -2, 2, 0, Math.PI * 2); lCtx.fill();
                lCtx.restore();
            }
        }

        class Plant {
            constructor(xPct) {
                this.xPct = xPct;
                this.h = 60 + Math.random() * 80;
            }
            draw(lakeBottom, iceTop) {
                const x = this.xPct * lWidth;
                // Only freeze if ice pile covers plant
                const plantTop = lakeBottom - this.h;
                const isFrozen = iceTop < plantTop;
                lCtx.save();
                lCtx.strokeStyle = isFrozen ? '#94a3b8' : '#15803d'; lCtx.lineWidth = 4; lCtx.lineCap = 'round';
                lCtx.beginPath(); lCtx.moveTo(x, lakeBottom);
                const sway = isFrozen ? 0 : Math.sin(Date.now() / 1000 + x) * 10;
                lCtx.quadraticCurveTo(x + sway, lakeBottom - this.h / 2, x + sway / 2, lakeBottom - this.h);
                lCtx.stroke(); lCtx.restore();
            }
        }

        class SinkingIce {
            constructor(surfaceY) {
                this.x = Math.random() * lWidth; this.y = surfaceY + Math.random() * 5;
                this.size = 6 + Math.random() * 8; this.vy = 1.2 + Math.random() * 1.5;
                this.rot = Math.random() * Math.PI; this.vRot = (Math.random() - 0.5) * 0.1;
                this.active = true;
            }
            update(targetY) {
                this.y += this.vy; this.rot += this.vRot;
                if (this.y >= targetY) { this.active = false; accumulatedBottomIce += 1.2; }
            }
            draw() {
                lCtx.save(); lCtx.translate(this.x, this.y); lCtx.rotate(this.rot);
                lCtx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                lCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                lCtx.restore();
            }
        }

        // --- Functions ---
        function getPos(e) {
            const rect = (e.target).getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        
        function syncGravity(val) {
            forceToggle.checked = val;
            forceToggleMobile.checked = val;
        }

        function updateMacroUI() {
            const m = Math.round(block.mass);
            const v = Math.round(block.volume);
            const d = block.density.toFixed(2);
            displays.m.innerText = m + ' g';
            displays.v.innerText = v + ' cm³';
            displays.d.innerText = d + ' g/cm³';
            displays.fM.innerText = m; displays.fV.innerText = v; displays.fD.innerText = d;

            if (block.density < 1.0) {
                displays.status.innerText = "Floating"; displays.status.className = "text-lg font-bold text-green-600";
            } else if (block.density > 1.0) {
                displays.status.innerText = "Sinking"; displays.status.className = "text-lg font-bold text-red-600";
            } else {
                displays.status.innerText = "Neutrally Buoyant"; displays.status.className = "text-lg font-bold text-blue-600";
            }
        }

        function updateBlockSize() { 
            const scaleFactor = width < 600 ? 10 : 15;
            block.size = scaleFactor * Math.pow(block.volume, 1 / 3); 
        }

        function drawArrow(ctx, fromX, fromY, length, direction, color, label) {
            if (length < 5) return;
            const headLen = width < 600 ? 8 : 12;
            const angle = direction === 'down' ? Math.PI / 2 : -Math.PI / 2;
            const toX = fromX + Math.cos(angle) * length;
            const toY = fromY + Math.sin(angle) * length;
            ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY);
            ctx.strokeStyle = color; ctx.lineWidth = width < 600 ? 2 : 4; ctx.lineCap = "round"; ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY); ctx.fillStyle = color; ctx.fill();
            if (label) {
                ctx.fillStyle = color; 
                ctx.font = width < 600 ? 'bold 10px sans-serif' : 'bold 12px sans-serif'; 
                ctx.textAlign = 'center';
                if (direction === 'down') ctx.fillText(label, toX, toY + (width < 600 ? 12 : 20));
                else ctx.fillText(label, toX, toY - (width < 600 ? 6 : 10));
            }
        }

        function updateLakeText() {
            if (isRealWorld) {
                lakeTitle.innerText = "Winter in the Lake (Real World)";
                lakeDesc.innerText = "Ice floats on top. This layer insulates the liquid water below, allowing aquatic life to survive the winter.";
            } else {
                lakeTitle.innerText = "Winter in the Lake (Hypothetical)";
                lakeDesc.innerText = "If ice were denser than water, it would sink! It would fall to the bottom, filling the lake upward and freezing all aquatic life.";
            }
        }

        function resizeMacro() {
            if (!canvas.parentElement) return;
            const container = canvas.parentElement;
            width = canvas.width = container.clientWidth;
            height = canvas.height = container.clientHeight;
            waterLevel = height * MACRO_CONFIG.WATER_LEVEL_RATIO;
            if (block.x === 0 || block.x > width) block.x = width / 2 - block.size / 2;
            if (block.y === 0) block.y = height * 0.2;
            updateBlockSize();
        }

        function resizeMicro() {
            if (!microCanvas.parentElement) return;
            const container = microCanvas.parentElement;
            mWidth = microCanvas.width = container.clientWidth;
            mHeight = microCanvas.height = container.clientHeight;
            if (molecules.length > 0) {
                let minX = 10000, maxX = -10000, minY = 10000, maxY = -10000;
                molecules.forEach(m => {
                    if (m.targetX < minX) minX = m.targetX; if (m.targetX > maxX) maxX = m.targetX;
                    if (m.targetY < minY) minY = m.targetY; if (m.targetY > maxY) maxY = m.targetY;
                });
                const w = maxX - minX; const h = maxY - minY;
                const offsetX = (mWidth - w) / 2 - minX; const offsetY = (mHeight - h) / 2 - minY;
                latticeBox = { x: (mWidth - w) / 2 - 40, y: (mHeight - h) / 2 - 40, w: w + 80, h: h + 80 };
                molecules.forEach(m => {
                    m.targetX += offsetX; m.targetY += offsetY;
                    if (m.x < 0 || m.x > mWidth) m.x = mWidth / 2;
                    if (m.y < 0 || m.y > mHeight) m.y = mHeight / 2;
                });
            }
        }

        function resizeLake() {
            if (!lakeCanvas.parentElement) return;
            const container = lakeCanvas.parentElement;
            lWidth = lakeCanvas.width = container.clientWidth;
            lHeight = lakeCanvas.height = container.clientHeight;
            if (fishArray.length === 0) initLake();
        }

        function resizeTower() {
             if (!towerCanvas.parentElement) return;
             const container = towerCanvas.parentElement;
             tWidth = towerCanvas.width = container.clientWidth;
             tHeight = towerCanvas.height = container.clientHeight;
        }

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            // Hide all controls
            document.getElementById('macroControls').classList.add('hidden');
            document.getElementById('macroControls').classList.remove('flex');
            document.getElementById('towerControls').classList.add('hidden');
            document.getElementById('towerControls').classList.remove('flex');
            document.getElementById('microControls').classList.add('hidden');
            document.getElementById('microControls').classList.remove('flex');
            document.getElementById('lakeControls').classList.add('hidden');
            document.getElementById('lakeControls').classList.remove('flex');

            if (tab === 'macro') {
                document.querySelector('button[onclick="switchTab(\'macro\')"]').classList.add('active');
                document.getElementById('tab-macro').classList.add('active');
                document.getElementById('macroControls').classList.remove('hidden');
                document.getElementById('macroControls').classList.add('flex');
                resizeMacro();
            } else if (tab === 'tower') {
                 document.querySelector('button[onclick="switchTab(\'tower\')"]').classList.add('active');
                document.getElementById('tab-tower').classList.add('active');
                document.getElementById('towerControls').classList.remove('hidden');
                document.getElementById('towerControls').classList.add('flex');
                resizeTower();
            } else if (tab === 'micro') {
                document.querySelector('button[onclick="switchTab(\'micro\')"]').classList.add('active');
                document.getElementById('tab-micro').classList.add('active');
                document.getElementById('microControls').classList.remove('hidden');
                document.getElementById('microControls').classList.add('flex');
                resizeMicro();
            } else {
                document.querySelector('button[onclick="switchTab(\'lake\')"]').classList.add('active');
                document.getElementById('tab-lake').classList.add('active');
                document.getElementById('lakeControls').classList.remove('hidden');
                document.getElementById('lakeControls').classList.add('flex');
                resizeLake();
            }
        }

        function updateLakeScenario(val) {
            isRealWorld = (val === 'real');
            lakeTemp = 20;
            lakeTempSlider.value = 20;
            document.getElementById('lakeTempVal').innerText = "20°C";
            document.getElementById('lakeTempVal').className = "font-bold text-emerald-600 text-sm";
            initLake();
            updateLakeText();
        }

        function addTowerLiquid(type) {
            const id = Date.now();
            liquidsAdded = true;
            // Enable solid buttons
            document.querySelectorAll('.solid-btn').forEach(btn => btn.disabled = false);
            
            if(type === 'water') towerLiquids.push(new TowerLiquid(id, "Water", 1.0, "rgba(59, 130, 246, 0.7)"));
            if(type === 'oil') towerLiquids.push(new TowerLiquid(id, "Oil", 0.9, "rgba(251, 191, 36, 0.7)"));
            if(type === 'honey') towerLiquids.push(new TowerLiquid(id, "Honey", 1.4, "rgba(180, 83, 9, 0.8)"));
        }

        function addTowerSolid(type) {
            if (!liquidsAdded) return;
            if(type === 'sponge') towerSolids.push(new TowerSolid("Sponge", 0.1, "#f9a8d4"));
            if(type === 'wax') towerSolids.push(new TowerSolid("Beeswax", 0.95, "#fef3c7"));
            if(type === 'plastic') towerSolids.push(new TowerSolid("Plastic", 1.0, "#38bdf8"));
            if(type === 'rubber') towerSolids.push(new TowerSolid("Rubber", 1.2, "#94a3b8"));
            if(type === 'brick') towerSolids.push(new TowerSolid("Brick", 1.9, "#991b1b"));
        }

        function resetTower() {
            towerLiquids = [];
            towerSolids = [];
            liquidsAdded = false;
            document.querySelectorAll('.solid-btn').forEach(btn => btn.disabled = true);
        }

        function initMicro() {
            molecules = [];
            const bondLen = 50; const wStep = bondLen * Math.sqrt(3);
            const cols = 9; const rows = 8;
            let count = 0;
            for (let r = 0; r < rows; r++) {
                let y = 0; const cycles = Math.floor(r / 2);
                y += cycles * (bondLen * 1.5); if (r % 2 === 1) y += bondLen * 0.5;
                for (let c = 0; c < cols; c++) {
                    const m = new Molecule(count++);
                    let x = c * wStep;
                    const rowMod = r % 4; if (rowMod === 1 || rowMod === 2) x += wStep / 2;
                    m.targetX = x; m.targetY = y; m.gridR = r; m.gridC = c;
                    m.x = x + (Math.random() - 0.5) * 100; m.y = y + (Math.random() - 0.5) * 100;
                    m.vx = (Math.random() - 0.5) * 1; m.vy = (Math.random() - 0.5) * 1;
                    molecules.push(m);
                }
            }
            molecules.sort((a, b) => (a.targetY - b.targetY) || (a.targetX - b.targetX));
            molecules.forEach(m => {
                let neighbors = molecules.filter(other => {
                    if (other === m) return false;
                    const d = Math.sqrt((m.targetX - other.targetX) ** 2 + (m.targetY - other.targetY) ** 2);
                    return d < bondLen * 1.5;
                });
                let incoming = neighbors.filter(n => n.donatesTo && n.donatesTo.includes(m));
                let candidates = neighbors.filter(n => !incoming.includes(n));
                candidates.sort((a, b) => b.targetY - a.targetY);
                m.donatesTo = candidates.slice(0, 2);
                if (m.donatesTo.length === 2) {
                    const t1 = m.donatesTo[0]; const t2 = m.donatesTo[1];
                    const a1 = Math.atan2(t1.targetY - m.targetY, t1.targetX - m.targetX);
                    const a2 = Math.atan2(t2.targetY - m.targetY, t2.targetX - m.targetX);
                    let bisect = (a1 + a2) / 2; if (Math.abs(a1 - a2) > Math.PI) bisect += Math.PI;
                    m.targetAngle = bisect;
                } else if (m.donatesTo.length === 1) {
                    const t1 = m.donatesTo[0];
                    const a1 = Math.atan2(t1.targetY - m.targetY, t1.targetX - m.targetX);
                    m.targetAngle = a1 + (60 * Math.PI / 180);
                } else { m.targetAngle = Math.PI / 2; }
            });
        }

        function initLake() {
            fishArray = []; plantArray = []; iceParticles = []; accumulatedBottomIce = 0;
            const width = (typeof lWidth !== 'undefined' && lWidth > 0) ? lWidth : 800;
            const fishCount = Math.max(8, Math.floor(width / 100));
            for (let i = 0; i < fishCount; i++) fishArray.push(new Fish());
            const plantCount = Math.max(10, Math.floor(width / 80));
            for (let i = 0; i < plantCount; i++) {
                const pct = 0.05 + (i / (plantCount - 1)) * 0.9;
                plantArray.push(new Plant(pct));
            }
        }

        function onDown(e) {
            const p = getPos(e); 
            mouse.x = p.x; mouse.y = p.y; mouse.down = true;

            if (currentTab === 'macro') {
                if (e.type === 'touchstart') e.preventDefault();
                if (p.x > block.x && p.x < block.x + block.size && p.y > block.y && p.y < block.y + block.size) block.isDragging = true;
            } else if (currentTab === 'tower') {
                 for(let i=towerSolids.length-1; i>=0; i--) {
                     const s = towerSolids[i];
                     if(p.x > s.x && p.x < s.x + s.size && p.y > s.y && p.y < s.y + s.size) {
                         s.isDragging = true;
                         towerSolids.splice(i, 1);
                         towerSolids.push(s);
                         mouse.px = s.x; mouse.py = s.y; 
                         break;
                     }
                 }
            }
        }
        function onMove(e) {
            if (e.type === 'touchmove' && (currentTab === 'macro' || currentTab === 'tower')) e.preventDefault();
            const p = getPos(e); mouse.px = mouse.x; mouse.py = mouse.y; mouse.x = p.x; mouse.y = p.y;
            
            if(currentTab === 'tower') {
                 towerSolids.forEach(s => {
                     if(s.isDragging) {
                         s.x += mouse.x - mouse.px;
                         s.y += mouse.y - mouse.py;
                         s.vx = 0; s.vy = 0; 
                     }
                 });
            }
        }
        function onUp() {
            mouse.down = false;
            if (block.isDragging) {
                block.vx = (mouse.x - mouse.px) * 0.5;
                block.vy = (mouse.y - mouse.py) * 0.5;
            }
            block.isDragging = false;
            towerSolids.forEach(s => s.isDragging = false);
        }

        function updateMacroPhysics() {
            if (block.isDragging) {
                const targetX = mouse.x - block.size / 2;
                const targetY = mouse.y - block.size / 2;
                block.vx = (targetX - block.x) * 0.3;
                block.vy = (targetY - block.y) * 0.3;
                block.x += block.vx; block.y += block.vy;
                let submergedHeight = Math.max(0, Math.min(block.size, (block.y + block.size) - waterLevel));
                block.submergedRatio = submergedHeight / block.size;
            } else {
                const forceGravity = block.density * MACRO_CONFIG.GRAVITY;
                let submergedHeight = Math.max(0, Math.min(block.size, (block.y + block.size) - waterLevel));
                block.submergedRatio = submergedHeight / block.size;
                const forceBuoyancy = - (block.submergedRatio * MACRO_CONFIG.WATER_DENSITY * MACRO_CONFIG.GRAVITY);
                if (Math.abs(block.density - 1.0) < 0.02 && block.submergedRatio > 0.9) {
                    const waterMiddleY = waterLevel + (height - waterLevel) / 2;
                    const blockCenterY = block.y + block.size / 2;
                    block.vy += (waterMiddleY - blockCenterY) * 0.005;
                    block.vx *= 0.90; block.vy *= 0.90;
                } else {
                    block.vy += forceGravity + forceBuoyancy;
                    let currentDamping = block.submergedRatio > 0 ? 0.92 : MACRO_CONFIG.DAMPING;
                    block.vx *= currentDamping; block.vy *= currentDamping;
                }
                block.x += block.vx; block.y += block.vy;
            }
            if (block.y + block.size > height) { block.y = height - block.size; block.vy *= -0.3; }
            if (block.x < 0) { block.x = 0; block.vx *= -0.5; }
            if (block.x + block.size > width) { block.x = width - block.size; block.vx *= -0.5; }
        }

        function drawMacro() {
            ctx.clearRect(0, 0, width, height);

            // Sky Background
            const skyGradient = ctx.createLinearGradient(0, 0, 0, waterLevel);
            skyGradient.addColorStop(0, '#e0f2fe'); skyGradient.addColorStop(1, '#bae6fd');
            ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, width, waterLevel);

            // Sun
            ctx.fillStyle = '#fcd34d';
            ctx.shadowColor = 'rgba(252, 211, 77, 0.5)';
            ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(width - 50, 50, 30, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            // Cloud 1
            ctx.beginPath();
            ctx.arc(100, 70, 20, 0, Math.PI * 2);
            ctx.arc(130, 60, 25, 0, Math.PI * 2);
            ctx.arc(160, 70, 20, 0, Math.PI * 2);
            ctx.fill();

            // Cloud 2 (More clouds added)
            ctx.beginPath();
            ctx.arc(300, 50, 22, 0, Math.PI * 2);
            ctx.arc(335, 40, 28, 0, Math.PI * 2);
            ctx.arc(370, 50, 22, 0, Math.PI * 2);
            ctx.fill();

            // Cloud 3
            ctx.beginPath();
            ctx.arc(width - 200, 80, 18, 0, Math.PI * 2);
            ctx.arc(width - 170, 70, 24, 0, Math.PI * 2);
            ctx.arc(width - 140, 80, 18, 0, Math.PI * 2);
            ctx.fill();

            // Water
            const waterGradient = ctx.createLinearGradient(0, waterLevel, 0, height);
            waterGradient.addColorStop(0, 'rgba(56, 189, 248, 0.8)');
            waterGradient.addColorStop(1, 'rgba(3, 105, 161, 0.9)');
            ctx.fillStyle = waterGradient; ctx.fillRect(0, waterLevel, width, height - waterLevel);
            ctx.beginPath(); ctx.moveTo(0, waterLevel); ctx.lineTo(width, waterLevel);
            ctx.strokeStyle = '#bae6fd'; ctx.lineWidth = 2; ctx.stroke();

            ctx.save(); ctx.translate(block.x, block.y);
            ctx.fillStyle = `rgba(255, 255, 255, 0.6)`; ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.roundRect(0, 0, block.size, block.size, 8); ctx.fill(); ctx.stroke();

            let rawCount = Math.floor(block.mass / 15);
            const cols = Math.ceil(Math.sqrt(rawCount));
            const rows = Math.ceil(rawCount / cols);
            const margin = 10;
            const cellW = (block.size - margin * 2) / cols;
            const cellH = (block.size - margin * 2) / rows;
            ctx.fillStyle = '#0f172a';
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const jitter = 1.0;
                    const vx = (Math.random() - 0.5) * jitter;
                    const vy = (Math.random() - 0.5) * jitter;
                    const px = margin + (c * cellW) + (cellW / 2) + vx;
                    const py = margin + (r * cellH) + (cellH / 2) + vy;
                    ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI * 2); ctx.fill();
                    if (forceToggle.checked) {
                        ctx.save(); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py + 14);
                        ctx.moveTo(px - 3, py + 10); ctx.lineTo(px, py + 14); ctx.lineTo(px + 3, py + 10);
                        ctx.stroke(); ctx.restore();
                    }
                }
            }
            ctx.restore();

            if (forceToggle.checked) {
                const arrowScale = width < 600 ? 0.05 : 0.08;
                const gravityLen = block.mass * arrowScale;
                drawArrow(ctx, block.x + block.size + (width < 600 ? 15 : 30), block.y + block.size / 2 - gravityLen / 2, gravityLen, 'down', '#dc2626', 'Weight');
                const buoyancyLen = (block.volume * block.submergedRatio) * arrowScale;
                if (buoyancyLen > 5) drawArrow(ctx, block.x - (width < 600 ? 15 : 30), block.y + block.size / 2 + buoyancyLen / 2, buoyancyLen, 'up', '#2563eb', 'Buoyancy');
            }
        }

        function updateTowerLogic() {
            // Sort Liquids by Density
            towerLiquids.sort((a,b) => b.density - a.density);
            // Calculate stacks
            if(towerLiquids.length > 0) {
                const h = tHeight / towerLiquids.length;
                towerLiquids.forEach((l, i) => {
                    const targetY = tHeight - (i+1)*h;
                    l.update(targetY, h, tWidth);
                });
            }
            // Update Solids
            towerSolids.forEach(s => s.update(towerLiquids, tWidth, tHeight));
        }

        function drawTower() {
            tCtx.clearRect(0, 0, tWidth, tHeight);
            
            // Draw Liquids
            if(towerLiquids.length === 0) {
                tCtx.fillStyle = '#f1f5f9';
                tCtx.fillRect(0, 0, tWidth, tHeight);
                tCtx.fillStyle = '#94a3b8';
                tCtx.font = 'bold 20px sans-serif';
                tCtx.textAlign = 'center';
                tCtx.fillText("Add Liquids from the controls above!", tWidth/2, tHeight/2);
            } else {
                towerLiquids.forEach(l => l.draw(tCtx, tWidth));
            }

            // Draw Solids
            towerSolids.forEach(s => s.draw(tCtx));
        }

        function drawMicro() {
            const grad = mCtx.createRadialGradient(mWidth / 2, mHeight / 2, 0, mWidth / 2, mHeight / 2, mWidth);
            grad.addColorStop(0, '#1e293b'); grad.addColorStop(1, '#0f172a');
            mCtx.fillStyle = grad; mCtx.fillRect(0, 0, mWidth, mHeight);

            mCtx.save();
            mCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; mCtx.lineWidth = 2; mCtx.setLineDash([6, 4]);
            if (temperature > 0) {
                const boxW = mWidth * 0.35; const boxH = mHeight * 0.35;
                const startX = (mWidth - boxW) / 2; const startY = (mHeight - boxH) / 2;
                mCtx.strokeRect(startX, startY, boxW, boxH);
                mCtx.fillStyle = 'white'; mCtx.font = 'bold 14px sans-serif';
                mCtx.fillText("Liquid Volume (Compact & Dense)", startX + 10, startY - 10);
            } else {
                mCtx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                mCtx.strokeRect(latticeBox.x, latticeBox.y, latticeBox.w, latticeBox.h);
                mCtx.fillStyle = '#bae6fd'; mCtx.font = 'bold 14px sans-serif';
                mCtx.fillText("Solid Volume (Expanded)", latticeBox.x + 10, latticeBox.y - 10);
            }
            mCtx.restore();

            mCtx.save();
            mCtx.strokeStyle = temperature <= 0 ? 'rgba(250, 204, 21, 0.8)' : 'rgba(250, 204, 21, 0.3)';
            mCtx.lineWidth = 2; mCtx.setLineDash([4, 4]);
            const allAtoms = molecules.map(m => ({ m: m, ...m.getAtoms() }));
            const threshold = 40 * 40;
            for (let i = 0; i < allAtoms.length; i++) {
                const molA = allAtoms[i];
                for (let j = 0; j < allAtoms.length; j++) {
                    if (i === j) continue;
                    const molB = allAtoms[j];
                    const d1 = (molA.h1.x - molB.o.x) ** 2 + (molA.h1.y - molB.o.y) ** 2;
                    if (d1 < threshold) {
                        mCtx.beginPath(); mCtx.moveTo(molA.h1.x, molA.h1.y); mCtx.lineTo(molB.o.x, molB.o.y); mCtx.stroke();
                    }
                    const d2 = (molA.h2.x - molB.o.x) ** 2 + (molA.h2.y - molB.o.y) ** 2;
                    if (d2 < threshold) {
                        mCtx.beginPath(); mCtx.moveTo(molA.h2.x, molA.h2.y); mCtx.lineTo(molB.o.x, molB.o.y); mCtx.stroke();
                    }
                }
            }
            mCtx.restore();
            molecules.forEach(m => { m.update(mWidth, mHeight, temperature); m.draw(); });
        }

        function drawLake() {
            lCtx.clearRect(0, 0, lWidth, lHeight);
            const skyH = lHeight * 0.25;
            const lakeB = lHeight - 40;
            const waterS = skyH;

            // SKY & ATMOSPHERE
            const skyGrad = lCtx.createLinearGradient(0, 0, 0, skyH);
            skyGrad.addColorStop(0, '#0ea5e9');
            skyGrad.addColorStop(1, '#bae6fd');
            lCtx.fillStyle = skyGrad;
            lCtx.fillRect(0, 0, lWidth, skyH);

            // Sun
            lCtx.fillStyle = '#fcd34d';
            lCtx.shadowColor = 'rgba(252, 211, 77, 0.5)';
            lCtx.shadowBlur = 20;
            lCtx.beginPath(); lCtx.arc(lWidth - 80, 50, 30, 0, Math.PI * 2); lCtx.fill();
            lCtx.shadowBlur = 0;

            // Clouds
            lCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            lCtx.beginPath();
            lCtx.arc(100, 60, 20, 0, Math.PI * 2);
            lCtx.arc(130, 60, 25, 0, Math.PI * 2);
            lCtx.arc(160, 60, 20, 0, Math.PI * 2);
            lCtx.fill();

            lCtx.beginPath();
            lCtx.arc(lWidth / 2, 40, 25, 0, Math.PI * 2);
            lCtx.arc(lWidth / 2 + 30, 30, 30, 0, Math.PI * 2);
            lCtx.arc(lWidth / 2 + 60, 40, 20, 0, Math.PI * 2);
            lCtx.fill();

            // Water
            lCtx.fillStyle = '#0284c7';
            lCtx.fillRect(0, waterS, lWidth, lakeB - waterS);

            let freezeIntensity = 0;
            if (lakeTemp < 0) {
                freezeIntensity = Math.min(1, Math.abs(lakeTemp) / 20);
            }

            const totalWaterHeight = lakeB - waterS;
            let iceTopVal, iceBottomVal;

            if (isRealWorld) {
                const iceThickness = freezeIntensity * (totalWaterHeight * 0.3);
                iceBottomVal = waterS + iceThickness;
            } else {
                const iceHeight = Math.min(totalWaterHeight, accumulatedBottomIce);
                iceTopVal = lakeB - iceHeight;
            }

            if (!isRealWorld && lakeTemp < 0) {
                if (Math.random() < 0.2) iceParticles.push(new SinkingIce(waterS));
            }

            lCtx.fillStyle = '#ffffff';
            if (isRealWorld && freezeIntensity > 0) {
                lCtx.fillRect(0, waterS, lWidth, (iceBottomVal - waterS));
                lCtx.strokeStyle = '#cbd5e1';
                lCtx.beginPath(); lCtx.moveTo(0, iceBottomVal); lCtx.lineTo(lWidth, iceBottomVal); lCtx.stroke();
            } else if (!isRealWorld) {
                if (accumulatedBottomIce > 0) {
                    lCtx.fillRect(0, iceTopVal, lWidth, lakeB - iceTopVal);
                    lCtx.save();
                    lCtx.strokeStyle = '#e2e8f0';
                    lCtx.beginPath(); lCtx.moveTo(0, iceTopVal);
                    for (let i = 0; i < lWidth; i += 20) lCtx.lineTo(i, iceTopVal + (Math.random() - 0.5) * 10);
                    lCtx.lineTo(lWidth, iceTopVal); lCtx.stroke();
                    lCtx.restore();
                }
                const currentFloor = lakeB - accumulatedBottomIce;
                iceParticles.forEach(p => { p.update(currentFloor); if (p.active) p.draw(); });
                iceParticles = iceParticles.filter(p => p.active);
            }

            // Draw Plants with freezing logic
            const currentIceTop = isRealWorld ? 9999 : (lakeB - accumulatedBottomIce);
            plantArray.forEach(p => p.draw(lakeB, currentIceTop));

            let fishTop = waterS; let fishBottom = lakeB;
            if (isRealWorld) fishTop = iceBottomVal || waterS;
            else fishBottom = iceTopVal || lakeB;

            fishArray.forEach(f => { f.update(fishTop, fishBottom); f.draw(); });

            lCtx.fillStyle = '#44403c';
            lCtx.fillRect(0, lakeB, lWidth, 40);
        }

        // --- Event Listeners ---
        massSlider.addEventListener('input', (e) => {
            block.mass = parseFloat(e.target.value);
            block.density = block.mass / block.volume;
            densitySlider.value = block.density.toFixed(2);
            updateMacroUI();
        });
        volSlider.addEventListener('input', (e) => {
            block.volume = parseFloat(e.target.value);
            block.density = block.mass / block.volume;
            densitySlider.value = block.density.toFixed(2);
            updateBlockSize();
            updateMacroUI();
        });
        densitySlider.addEventListener('input', (e) => {
            block.density = parseFloat(e.target.value);
            block.mass = block.density * block.volume;
            if (block.mass > 3000) block.mass = 3000;
            if (block.mass < 100) block.mass = 100;
            block.density = block.mass / block.volume;
            massSlider.value = block.mass;
            updateMacroUI();
        });

        tempSlider.addEventListener('input', (e) => {
            temperature = parseInt(e.target.value);
            tempDisplay.innerText = temperature + "°C";
            if (temperature <= 0) {
                tempDisplay.className = "font-bold text-cyan-500 text-sm";
                phaseTitle.innerText = "Solid Ice:";
                phaseTitle.className = "text-cyan-600 font-bold";
                phaseDesc.innerText = "Stable Hydrogen bonds lock molecules into an OPEN hexagonal lattice. High volume, low density.";
            } else {
                tempDisplay.className = "font-bold text-blue-600 text-sm";
                phaseTitle.innerText = "Liquid Water:";
                phaseTitle.className = "text-blue-700 font-bold";
                phaseDesc.innerText = "Heat energy breaks bonds. Molecules slide closer together. Lower volume, higher density.";
            }
        });

        lakeTempSlider.addEventListener('input', (e) => {
            lakeTemp = parseInt(e.target.value);
            lakeTempDisplay.innerText = lakeTemp + "°C";
            if (lakeTemp <= 0) lakeTempDisplay.className = "font-bold text-cyan-600 text-sm";
            else lakeTempDisplay.className = "font-bold text-emerald-600 text-sm";
            if (lakeTemp > 0) fishArray.forEach(f => f.alive = true);
        });

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchstart', onDown, { passive: false });
        canvas.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onUp);
        
        towerCanvas.addEventListener('mousedown', onDown);
        towerCanvas.addEventListener('mousemove', onMove);
        towerCanvas.addEventListener('touchstart', onDown, { passive: false });
        towerCanvas.addEventListener('touchmove', onMove, { passive: false });

        window.addEventListener('resize', () => {
            resizeMacro();
            resizeMicro();
            resizeLake();
            resizeTower();
        });
        
        window.addEventListener('orientationchange', () => {
             setTimeout(() => {
                resizeMacro();
                resizeMicro();
                resizeLake();
                resizeTower();
             }, 100);
        });

        function loop() {
            if (currentTab === 'macro') {
                updateMacroPhysics();
                drawMacro();
            } else if (currentTab === 'tower') {
                updateTowerLogic();
                drawTower();
            } else if (currentTab === 'micro') {
                drawMicro();
            } else if (currentTab === 'lake') {
                drawLake();
            }
            requestAnimationFrame(loop);
        }

        // Init
        resizeMacro();
        resizeTower();
        initMicro();
        resizeMicro();
        updateBlockSize();
        updateMacroUI();
        initLake();
        loop();

    </script>
</body>

</html>